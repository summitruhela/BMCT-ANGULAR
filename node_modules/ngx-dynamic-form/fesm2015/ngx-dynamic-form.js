import { Component, HostBinding, IterableDiffers, Input, EventEmitter, Output, Directive, ViewContainerRef, ComponentFactoryResolver, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { FormBuilder, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { NgDatepickerModule } from 'ng2-datepicker';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormInputComponent {
    constructor() { }
    /**
     * @return {?}
     */
    get hostClass() {
        return this.config.divClass;
    }
}
FormInputComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'form-input',
                styles: [`input[type=submit]{margin-top:.5rem 1rem}.form-input{height:38px;border-radius:3.5px;background-color:#fff;border:1px solid #bdbdbd;margin-bottom:15px}label{margin-bottom:8px;font-size:16px}`, `input[type=submit]{margin-top:.5rem 1rem}.form-input{height:38px;border-radius:3.5px;background-color:#fff;border:1px solid #bdbdbd;margin-bottom:15px}label{margin-bottom:8px;font-size:16px}`],
                template: `<div *ngIf='!config.hidden' [formGroup]="formGroup">
    <label [ngClass]="config.labelClass" *ngIf="config.label && config.label!=''">{{ config.label }}</label>
    <input *ngIf="config.type ==='input' && !config.fromEnum " class="form-input" value={{config.text}} [disabled]="config.disabled" type={{config.inputType}} [ngClass]="config.class" [attr.placeholder]="config.placeholder" [formControlName]="config.name"
    />

    <select *ngIf="config.type==='select' && !config.fromEnum && !config.hidden" class="form-input" [formControlName]="config.name" [ngClass]=config.class>
        <option value='' [selected]="true">{{ config.placeholder }}</option>
        <option value={{option}}
                *ngFor="let option of config.options">
                {{option}}
        </option>
    </select>
    <select class="form-input" *ngIf="config.type==='select' && config.fromEnum && !config.hidden" [formControlName]="config.name" [ngClass]=config.class>
        <option value="" [selected]="true">{{ config.placeholder }}</option>
        <option value={{config.options[0][i]}}
                *ngFor="let o of config.options[0]; let i=index">
                {{ config.options[1][i] }}
        </option>
    </select>

    <textarea class="form-input" *ngIf="config.type==='textarea' && !config.hidden" [formControlName]="config.name" [attr.placeholder]="config.placeholder" rows={{config.rows}} cols={{config.cols}}></textarea>

    <ng-datepicker class="form-input" [ngClass]="config.class" *ngIf="config.type ==='date'" [formControlName]="config.name"></ng-datepicker>
</div>`
            },] },
];
/** @nocollapse */
FormInputComponent.ctorParameters = () => [];
FormInputComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormSelectComponent {
    /**
     * @return {?}
     */
    get hostClass() {
        return this.config.divClass;
    }
    /**
     * Converts and Enum Object to an Array
     * @param {?} arg  Enum
     * @return {?} Array<Array<any>>
     */
    enumToArray(arg) {
        /** @type {?} */
        const numKeyArr = [];
        /** @type {?} */
        const valArr = [];
        /** @type {?} */
        const returnedArray = [];
        /** @type {?} */
        const objKeys = Object.keys(arg);
        objKeys.forEach(key => {
            /** @type {?} */
            const numberKey = Number(key);
            if (!isNaN(numberKey)) {
                numKeyArr.push(numberKey);
            }
            else {
                valArr.push(key);
            }
        });
        returnedArray[0] = numKeyArr;
        returnedArray[1] = valArr;
        return returnedArray;
    }
}
FormSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'form-select',
                styles: [``, `input[type=submit]{margin-top:.5rem 1rem}.form-input{height:38px;border-radius:3.5px;background-color:#fff;border:1px solid #bdbdbd;margin-bottom:15px}label{margin-bottom:8px;font-size:16px}`],
                template: `<div *ngIf='!config.hidden' [formGroup]="formGroup">
    <label [ngClass]="config.labelClass" *ngIf="config.label && config.label!=''">{{ config.label }}</label>
    <div class="dynamic-field form-select">
        <select *ngIf="!config.enum" class="form-input" [hidden]='config.hidden' [formControlName]="config.name" [ngClass]=config.class>
                <option value='' [selected]="true">{{ config.placeholder }}</option>
                <option *ngFor="let option of config.options"
                        [value]='option'>
                        {{option}}
                </option>

        </select>
        <select [formControlName]="config.name" class="form-input" [ngClass]=config.class *ngIf="config.enum">
                <option value='' [selected]="true">{{ config.placeholder }}</option>
                <option *ngFor="let o of enumToArray(config.enum)[0]; let i=index"
                        [value]='enumToArray(config.enum)[0][i]'>
                        {{ enumToArray(config.enum)[1][i] }}
                </option>
        </select>
    </div>
</div>`
            },] },
];
FormSelectComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormFileUploadComponent {
    /**
     * @return {?}
     */
    get hostClass() {
        return this.config.divClass;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleFileUpload(event) {
        (/** @type {?} */ (this.formGroup.controls[this.config.name]))
            .setValue(this.config.multiple ? event.currentTarget.files : event.currentTarget.files[0]);
    }
}
FormFileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'form-file-upload',
                styles: [``, `input[type=submit]{margin-top:.5rem 1rem}.form-input{height:38px;border-radius:3.5px;background-color:#fff;border:1px solid #bdbdbd;margin-bottom:15px}label{margin-bottom:8px;font-size:16px}`],
                template: `<div *ngIf='!config.hidden' [formGroup]="formGroup">
    <label [ngClass]="config.labelClass" *ngIf="config.label && config.label!=''">{{ config.label }}</label>
    <div class="dynamic-field form-select">
        <input [disabled]="config.disabled" class="form-input" type='file' (change)='handleFileUpload($event)' [accept]="config.accept" [ngClass]="config.class" [attr.placeholder]="config.placeholder" />
    </div>
</div>`
            },] },
];
FormFileUploadComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormDatetimeComponent {
    /**
     * @return {?}
     */
    get hostClass() {
        return this.config.divClass;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        (/** @type {?} */ (this.formGroup.controls[this.config.name]))
            .setValue(new Date(), { onlySelf: true });
    }
}
FormDatetimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'form-datetime',
                styles: [``, `input[type=submit]{margin-top:.5rem 1rem}.form-input{height:38px;border-radius:3.5px;background-color:#fff;border:1px solid #bdbdbd;margin-bottom:15px}label{margin-bottom:8px;font-size:16px}`],
                template: `<div *ngIf='!config.hidden' [formGroup]="formGroup">
    <label *ngIf="config.label && config.label!=''">{{ config.label }}</label>
    <div class="dynamic-field form-datetime">
        <ng-datepicker class="form-input" [formControlName]="config.name"></ng-datepicker>

    </div>
</div>`
            },] },
];
FormDatetimeComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FormButtonComponent {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        this.differ = differs.find([]).create(null);
    }
    /**
     * @return {?}
     */
    get hostClass() {
        return this.config.divClass;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        setTimeout(() => {
            /** @type {?} */
            const change = this.differ.diff(this.btn);
            if (document.querySelector('form').className.includes('ng-invalid')
                && this.config.inputType.toLowerCase() === 'submit') {
                this.config.disabled = true;
            }
            else {
                this.config.disabled = false;
            }
        }, 10);
    }
}
FormButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'form-button',
                styles: [``],
                template: `<div *ngIf='!config.hidden' class="form-input" [formGroup]="formGroup">
    <label [ngClass]="config.labelClass" *ngIf="config.label && config.label!=''">{{ config.label }}</label>
    <div class="dynamic-field form-button">
        <button [disabled]="config.disabled" [ngClass]="config.class" type="submit">
        {{ config.text }}
        </button>
    </div>
</div>`
            },] },
];
/** @nocollapse */
FormButtonComponent.ctorParameters = () => [
    { type: IterableDiffers }
];
FormButtonComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DynamicFormComponent {
    /**
     * @param {?} fb
     */
    constructor(fb) {
        this.fb = fb;
        this.config = [];
        this.submit = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get controls() { return this.config.filter(({ type }) => type !== 'button'); }
    /**
     * @return {?}
     */
    get changes() { return this.form.valueChanges; }
    /**
     * @return {?}
     */
    get valid() { return this.form.valid; }
    /**
     * @return {?}
     */
    get value() { return this.form.value; }
    /**
     * @return {?}
     */
    reset() { this.form.reset(); }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.form = this.createGroup();
    }
    /**
     * Create FormGroup for the Form to be generated
     * @return {?}
     */
    createGroup() {
        /** @type {?} */
        const formGroup = this.fb.group({});
        this.config.forEach(control => {
            formGroup.addControl(control.name, this.createControl(control));
        });
        return formGroup;
    }
    /**
     * Create Form Control in FormBuilder
     * @param {?} config
     * @return {?}
     */
    createControl(config) {
        const { disabled, validation, value } = config;
        return this.fb.control({ disabled, value }, validation);
    }
    /**
     * Handle Form Submit
     * @param {?} event
     * @return {?}
     */
    handleSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        this.submit.emit(this.value);
    }
    /**
     * Disables an element in the form
     * @param {?} name
     * @param {?} disable
     * @return {?}
     */
    setDisabled(name, disable) {
        if (this.form.controls[name]) {
            /** @type {?} */
            const method = disable ? 'disable' : 'enable';
            this.form.controls[name][method]();
            return;
        }
        this.config = this.config.map((item) => {
            if (item.name === name) {
                item.disabled = disable;
            }
            return item;
        });
    }
    /**
     * Sets value of a Form control/element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    setValue(name, value) {
        this.form.controls[name].setValue(value, { emitEvent: true });
    }
}
DynamicFormComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'dynamicForm',
                // tslint:disable-next-line:component-selector
                selector: 'dynamic-form',
                styles: [`.__ngx-form-container{display:flex;flex-wrap:wrap}`],
                template: `<form [formGroup]="form" #newForm="ngForm" (ngSubmit)="handleSubmit($event)">
    <div class="__ngx-form-container">
        <div dynamicField *ngFor="let field of config" [config]="field" [formGroup]="form">
        </div>
    </div>
</form>`
            },] },
];
/** @nocollapse */
DynamicFormComponent.ctorParameters = () => [
    { type: FormBuilder }
];
DynamicFormComponent.propDecorators = {
    config: [{ type: Input }],
    submit: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @type {?} */
const components = {
    button: FormButtonComponent,
    input: FormInputComponent,
    select: FormSelectComponent,
    file: FormFileUploadComponent,
    date: FormDatetimeComponent
};
class DynamicAddFieldDirective {
    /**
     * @param {?} resolver
     * @param {?} vcr
     */
    constructor(resolver, vcr) {
        this.resolver = resolver;
        this.vcr = vcr;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!components[this.config.type]) {
            /** @type {?} */
            const supportedTypes = Object.keys(components).join(', ');
            throw new Error(`Trying to use an unsupported type (${this.config.type}).
            Supported types: ${supportedTypes}`);
        }
        /** @type {?} */
        const component = components[this.config.type];
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(component);
        this.component = this.vcr.createComponent(factory);
        this.component.instance.config = this.config;
        this.component.instance.formGroup = this.formGroup;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.component) {
            this.component.instance.config = this.config;
            this.component.instance.formGroup = this.formGroup;
        }
    }
}
DynamicAddFieldDirective.decorators = [
    { type: Directive, args: [{ selector: '[dynamicField]' },] },
];
/** @nocollapse */
DynamicAddFieldDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
DynamicAddFieldDirective.propDecorators = {
    config: [{ type: Input }],
    formGroup: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DynamicFormModule$$1 {
}
DynamicFormModule$$1.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    NgDatepickerModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    DynamicAddFieldDirective,
                    DynamicFormComponent,
                    FormInputComponent,
                    FormSelectComponent,
                    FormFileUploadComponent,
                    FormDatetimeComponent,
                    FormButtonComponent
                ],
                providers: [],
                exports: [
                    NgDatepickerModule,
                    DynamicFormComponent
                ], schemas: [
                    CUSTOM_ELEMENTS_SCHEMA
                ],
                entryComponents: [
                    FormInputComponent,
                    FormSelectComponent,
                    FormFileUploadComponent,
                    FormDatetimeComponent,
                    FormButtonComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { FormInputComponent, FormSelectComponent, FormFileUploadComponent, FormDatetimeComponent, FormButtonComponent, DynamicFormComponent, DynamicAddFieldDirective, DynamicFormModule$$1 as DynamicFormModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWR5bmFtaWMtZm9ybS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWR5bmFtaWMtZm9ybS9saWIvY29tcG9uZW50cy9mb3JtLWlucHV0L2Zvcm0taW5wdXQuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtZHluYW1pYy1mb3JtL2xpYi9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtZHluYW1pYy1mb3JtL2xpYi9jb21wb25lbnRzL2ZpbGUtdXBsb2FkL2ZpbGUtdXBsb2FkLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWR5bmFtaWMtZm9ybS9saWIvY29tcG9uZW50cy9kYXRldGltZS9kYXRldGltZS5jb21wb25lbnQudHMiLCJuZzovL25neC1keW5hbWljLWZvcm0vbGliL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5jb21wb25lbnQudHMiLCJuZzovL25neC1keW5hbWljLWZvcm0vbGliL2NvbnRhaW5lcnMvZHluYW1pYy1mb3JtL2R5bmFtaWMtZm9ybS5jb21wb25lbnQudHMiLCJuZzovL25neC1keW5hbWljLWZvcm0vbGliL2RpcmVjdGl2ZXMvZHluYW1pYy1hZGQtZmllbGQvZHluYW1pYy1hZGQtZmllbGQuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtZHluYW1pYy1mb3JtL2xpYi9keW5hbWljLWZvcm0ubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9maWVsZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmllbGRDb25maWcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpZWxkLWNvbmZpZy5pbnRlcmZhY2UnO1xuXG5cbkBDb21wb25lbnQoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ2Zvcm0taW5wdXQnLFxuICAgIHN0eWxlczogW2BpbnB1dFt0eXBlPXN1Ym1pdF17bWFyZ2luLXRvcDouNXJlbSAxcmVtfS5mb3JtLWlucHV0e2hlaWdodDozOHB4O2JvcmRlci1yYWRpdXM6My41cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2JkYmRiZDttYXJnaW4tYm90dG9tOjE1cHh9bGFiZWx7bWFyZ2luLWJvdHRvbTo4cHg7Zm9udC1zaXplOjE2cHh9YCwgYGlucHV0W3R5cGU9c3VibWl0XXttYXJnaW4tdG9wOi41cmVtIDFyZW19LmZvcm0taW5wdXR7aGVpZ2h0OjM4cHg7Ym9yZGVyLXJhZGl1czozLjVweDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjYmRiZGJkO21hcmdpbi1ib3R0b206MTVweH1sYWJlbHttYXJnaW4tYm90dG9tOjhweDtmb250LXNpemU6MTZweH1gXSxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9JyFjb25maWcuaGlkZGVuJyBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuICAgIDxsYWJlbCBbbmdDbGFzc109XCJjb25maWcubGFiZWxDbGFzc1wiICpuZ0lmPVwiY29uZmlnLmxhYmVsICYmIGNvbmZpZy5sYWJlbCE9JydcIj57eyBjb25maWcubGFiZWwgfX08L2xhYmVsPlxuICAgIDxpbnB1dCAqbmdJZj1cImNvbmZpZy50eXBlID09PSdpbnB1dCcgJiYgIWNvbmZpZy5mcm9tRW51bSBcIiBjbGFzcz1cImZvcm0taW5wdXRcIiB2YWx1ZT17e2NvbmZpZy50ZXh0fX0gW2Rpc2FibGVkXT1cImNvbmZpZy5kaXNhYmxlZFwiIHR5cGU9e3tjb25maWcuaW5wdXRUeXBlfX0gW25nQ2xhc3NdPVwiY29uZmlnLmNsYXNzXCIgW2F0dHIucGxhY2Vob2xkZXJdPVwiY29uZmlnLnBsYWNlaG9sZGVyXCIgW2Zvcm1Db250cm9sTmFtZV09XCJjb25maWcubmFtZVwiXG4gICAgLz5cblxuICAgIDxzZWxlY3QgKm5nSWY9XCJjb25maWcudHlwZT09PSdzZWxlY3QnICYmICFjb25maWcuZnJvbUVudW0gJiYgIWNvbmZpZy5oaWRkZW5cIiBjbGFzcz1cImZvcm0taW5wdXRcIiBbZm9ybUNvbnRyb2xOYW1lXT1cImNvbmZpZy5uYW1lXCIgW25nQ2xhc3NdPWNvbmZpZy5jbGFzcz5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT0nJyBbc2VsZWN0ZWRdPVwidHJ1ZVwiPnt7IGNvbmZpZy5wbGFjZWhvbGRlciB9fTwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPXt7b3B0aW9ufX1cbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIGNvbmZpZy5vcHRpb25zXCI+XG4gICAgICAgICAgICAgICAge3tvcHRpb259fVxuICAgICAgICA8L29wdGlvbj5cbiAgICA8L3NlbGVjdD5cbiAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1pbnB1dFwiICpuZ0lmPVwiY29uZmlnLnR5cGU9PT0nc2VsZWN0JyAmJiBjb25maWcuZnJvbUVudW0gJiYgIWNvbmZpZy5oaWRkZW5cIiBbZm9ybUNvbnRyb2xOYW1lXT1cImNvbmZpZy5uYW1lXCIgW25nQ2xhc3NdPWNvbmZpZy5jbGFzcz5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiIFtzZWxlY3RlZF09XCJ0cnVlXCI+e3sgY29uZmlnLnBsYWNlaG9sZGVyIH19PC9vcHRpb24+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9e3tjb25maWcub3B0aW9uc1swXVtpXX19XG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IG8gb2YgY29uZmlnLm9wdGlvbnNbMF07IGxldCBpPWluZGV4XCI+XG4gICAgICAgICAgICAgICAge3sgY29uZmlnLm9wdGlvbnNbMV1baV0gfX1cbiAgICAgICAgPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG5cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWlucHV0XCIgKm5nSWY9XCJjb25maWcudHlwZT09PSd0ZXh0YXJlYScgJiYgIWNvbmZpZy5oaWRkZW5cIiBbZm9ybUNvbnRyb2xOYW1lXT1cImNvbmZpZy5uYW1lXCIgW2F0dHIucGxhY2Vob2xkZXJdPVwiY29uZmlnLnBsYWNlaG9sZGVyXCIgcm93cz17e2NvbmZpZy5yb3dzfX0gY29scz17e2NvbmZpZy5jb2xzfX0+PC90ZXh0YXJlYT5cblxuICAgIDxuZy1kYXRlcGlja2VyIGNsYXNzPVwiZm9ybS1pbnB1dFwiIFtuZ0NsYXNzXT1cImNvbmZpZy5jbGFzc1wiICpuZ0lmPVwiY29uZmlnLnR5cGUgPT09J2RhdGUnXCIgW2Zvcm1Db250cm9sTmFtZV09XCJjb25maWcubmFtZVwiPjwvbmctZGF0ZXBpY2tlcj5cbjwvZGl2PmBcbn0pXG5cbmV4cG9ydCBjbGFzcyBGb3JtSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBGaWVsZCB7XG4gICAgY29uZmlnOiBGaWVsZENvbmZpZztcbiAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cDtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gICAgZ2V0IGhvc3RDbGFzcygpOiBzdHJpbmcge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRpdkNsYXNzO1xuICAgICAgICB9XG59XG5cbiIsImltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpZWxkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWVsZENvbmZpZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQtY29uZmlnLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm0tc2VsZWN0JyxcbiAgc3R5bGVzOiBbYGAsIGBpbnB1dFt0eXBlPXN1Ym1pdF17bWFyZ2luLXRvcDouNXJlbSAxcmVtfS5mb3JtLWlucHV0e2hlaWdodDozOHB4O2JvcmRlci1yYWRpdXM6My41cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2JkYmRiZDttYXJnaW4tYm90dG9tOjE1cHh9bGFiZWx7bWFyZ2luLWJvdHRvbTo4cHg7Zm9udC1zaXplOjE2cHh9YF0sXG4gIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj0nIWNvbmZpZy5oaWRkZW4nIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG4gICAgPGxhYmVsIFtuZ0NsYXNzXT1cImNvbmZpZy5sYWJlbENsYXNzXCIgKm5nSWY9XCJjb25maWcubGFiZWwgJiYgY29uZmlnLmxhYmVsIT0nJ1wiPnt7IGNvbmZpZy5sYWJlbCB9fTwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImR5bmFtaWMtZmllbGQgZm9ybS1zZWxlY3RcIj5cbiAgICAgICAgPHNlbGVjdCAqbmdJZj1cIiFjb25maWcuZW51bVwiIGNsYXNzPVwiZm9ybS1pbnB1dFwiIFtoaWRkZW5dPSdjb25maWcuaGlkZGVuJyBbZm9ybUNvbnRyb2xOYW1lXT1cImNvbmZpZy5uYW1lXCIgW25nQ2xhc3NdPWNvbmZpZy5jbGFzcz5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPScnIFtzZWxlY3RlZF09XCJ0cnVlXCI+e3sgY29uZmlnLnBsYWNlaG9sZGVyIH19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIGNvbmZpZy5vcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09J29wdGlvbic+XG4gICAgICAgICAgICAgICAgICAgICAgICB7e29wdGlvbn19XG4gICAgICAgICAgICAgICAgPC9vcHRpb24+XG5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDxzZWxlY3QgW2Zvcm1Db250cm9sTmFtZV09XCJjb25maWcubmFtZVwiIGNsYXNzPVwiZm9ybS1pbnB1dFwiIFtuZ0NsYXNzXT1jb25maWcuY2xhc3MgKm5nSWY9XCJjb25maWcuZW51bVwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9JycgW3NlbGVjdGVkXT1cInRydWVcIj57eyBjb25maWcucGxhY2Vob2xkZXIgfX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uICpuZ0Zvcj1cImxldCBvIG9mIGVudW1Ub0FycmF5KGNvbmZpZy5lbnVtKVswXTsgbGV0IGk9aW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT0nZW51bVRvQXJyYXkoY29uZmlnLmVudW0pWzBdW2ldJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVudW1Ub0FycmF5KGNvbmZpZy5lbnVtKVsxXVtpXSB9fVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgRm9ybVNlbGVjdENvbXBvbmVudCBpbXBsZW1lbnRzIEZpZWxkIHtcbiAgY29uZmlnOiBGaWVsZENvbmZpZztcbiAgZm9ybUdyb3VwOiBGb3JtR3JvdXA7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gICAgZ2V0IGhvc3RDbGFzcygpOiBzdHJpbmcge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRpdkNsYXNzO1xuICAgICAgICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbmQgRW51bSBPYmplY3QgdG8gYW4gQXJyYXkgXG4gICAqIEBwYXJhbSBhcmcgIEVudW1cbiAgICogQHJldHVybnMgQXJyYXk8QXJyYXk8YW55Pj5cbiAgICovXG4gIGVudW1Ub0FycmF5KGFyZzogT2JqZWN0KTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG51bUtleUFyciA9IFtdOyBcbiAgICBjb25zdCB2YWxBcnIgPSBbXTsgXG4gICAgY29uc3QgcmV0dXJuZWRBcnJheSA9IFtdO1xuXG4gICAgY29uc3Qgb2JqS2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBvYmpLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgbnVtYmVyS2V5ID0gTnVtYmVyKGtleSlcbiAgICAgICAgaWYoIWlzTmFOKG51bWJlcktleSkpe1xuICAgICAgICBudW1LZXlBcnIucHVzaChudW1iZXJLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsQXJyLnB1c2goa2V5KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuZWRBcnJheVswXSA9IG51bUtleUFycjtcbiAgICByZXR1cm5lZEFycmF5WzFdID0gdmFsQXJyO1xuICAgIHJldHVybiByZXR1cm5lZEFycmF5O1xuICB9XG5cbn1cblxuXG5pbnRlcmZhY2UgU2VsZWN0Q29uZmlnIGV4dGVuZHMgRmllbGRDb25maWd7XG4gICAgZW51bTogYm9vbGVhbixcbiAgICBvcHRpb25zPzogc3RyaW5nW11cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtR3JvdXAsIEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpZWxkQ29uZmlnIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9maWVsZC1jb25maWcuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZm9ybS1maWxlLXVwbG9hZCcsXG4gIHN0eWxlczogW2BgLCBgaW5wdXRbdHlwZT1zdWJtaXRde21hcmdpbi10b3A6LjVyZW0gMXJlbX0uZm9ybS1pbnB1dHtoZWlnaHQ6MzhweDtib3JkZXItcmFkaXVzOjMuNXB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNiZGJkYmQ7bWFyZ2luLWJvdHRvbToxNXB4fWxhYmVse21hcmdpbi1ib3R0b206OHB4O2ZvbnQtc2l6ZToxNnB4fWBdLFxuICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9JyFjb25maWcuaGlkZGVuJyBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuICAgIDxsYWJlbCBbbmdDbGFzc109XCJjb25maWcubGFiZWxDbGFzc1wiICpuZ0lmPVwiY29uZmlnLmxhYmVsICYmIGNvbmZpZy5sYWJlbCE9JydcIj57eyBjb25maWcubGFiZWwgfX08L2xhYmVsPlxuICAgIDxkaXYgY2xhc3M9XCJkeW5hbWljLWZpZWxkIGZvcm0tc2VsZWN0XCI+XG4gICAgICAgIDxpbnB1dCBbZGlzYWJsZWRdPVwiY29uZmlnLmRpc2FibGVkXCIgY2xhc3M9XCJmb3JtLWlucHV0XCIgdHlwZT0nZmlsZScgKGNoYW5nZSk9J2hhbmRsZUZpbGVVcGxvYWQoJGV2ZW50KScgW2FjY2VwdF09XCJjb25maWcuYWNjZXB0XCIgW25nQ2xhc3NdPVwiY29uZmlnLmNsYXNzXCIgW2F0dHIucGxhY2Vob2xkZXJdPVwiY29uZmlnLnBsYWNlaG9sZGVyXCIgLz5cbiAgICA8L2Rpdj5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgRm9ybUZpbGVVcGxvYWRDb21wb25lbnQgaW1wbGVtZW50cyBGaWVsZCB7XG4gIGNvbmZpZzogRmlsZUNvbmZpZztcbiAgZm9ybUdyb3VwOiBGb3JtR3JvdXA7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gICAgZ2V0IGhvc3RDbGFzcygpOiBzdHJpbmcge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRpdkNsYXNzO1xuICAgICAgICB9XG5cbiAgaGFuZGxlRmlsZVVwbG9hZChldmVudCl7XG4gICAgKDxGb3JtQ29udHJvbD50aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLmNvbmZpZy5uYW1lXSlcbiAgICAuc2V0VmFsdWUodGhpcy5jb25maWcubXVsdGlwbGU/ICBldmVudC5jdXJyZW50VGFyZ2V0LmZpbGVzOiBldmVudC5jdXJyZW50VGFyZ2V0LmZpbGVzWzBdKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQ29uZmlnIGV4dGVuZHMgRmllbGRDb25maWd7XG4gICAgICBtdWx0aXBsZTogYm9vbGVhbixcbiAgICAgIGFjY2VwdDogc3RyaW5nLFxuXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpZWxkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWVsZENvbmZpZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQtY29uZmlnLmludGVyZmFjZSc7XG5pbXBvcnQgeyBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3NyYy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3MnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmb3JtLWRhdGV0aW1lJyxcbiAgc3R5bGVzOiBbYGAsIGBpbnB1dFt0eXBlPXN1Ym1pdF17bWFyZ2luLXRvcDouNXJlbSAxcmVtfS5mb3JtLWlucHV0e2hlaWdodDozOHB4O2JvcmRlci1yYWRpdXM6My41cHg7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2JkYmRiZDttYXJnaW4tYm90dG9tOjE1cHh9bGFiZWx7bWFyZ2luLWJvdHRvbTo4cHg7Zm9udC1zaXplOjE2cHh9YF0sXG4gIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj0nIWNvbmZpZy5oaWRkZW4nIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG4gICAgPGxhYmVsICpuZ0lmPVwiY29uZmlnLmxhYmVsICYmIGNvbmZpZy5sYWJlbCE9JydcIj57eyBjb25maWcubGFiZWwgfX08L2xhYmVsPlxuICAgIDxkaXYgY2xhc3M9XCJkeW5hbWljLWZpZWxkIGZvcm0tZGF0ZXRpbWVcIj5cbiAgICAgICAgPG5nLWRhdGVwaWNrZXIgY2xhc3M9XCJmb3JtLWlucHV0XCIgW2Zvcm1Db250cm9sTmFtZV09XCJjb25maWcubmFtZVwiPjwvbmctZGF0ZXBpY2tlcj5cblxuICAgIDwvZGl2PlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGb3JtRGF0ZXRpbWVDb21wb25lbnQgaW1wbGVtZW50cyBGaWVsZCwgT25Jbml0IHtcbiAgXG4gIGNvbmZpZzogRmllbGRDb25maWc7XG4gIGZvcm1Hcm91cDogRm9ybUdyb3VwO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGdldCBob3N0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5kaXZDbGFzcztcbiAgICAgICAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICg8Rm9ybUNvbnRyb2w+dGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5jb25maWcubmFtZV0pXG4gICAgLnNldFZhbHVlKG5ldyBEYXRlKCksIHsgb25seVNlbGY6IHRydWUgfSk7XG4gIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEl0ZXJhYmxlRGlmZmVycywgQWZ0ZXJWaWV3SW5pdCwgRG9DaGVjaywgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpZWxkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWVsZENvbmZpZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQtY29uZmlnLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm0tYnV0dG9uJyxcbiAgc3R5bGVzOiBbYGBdLFxuICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9JyFjb25maWcuaGlkZGVuJyBjbGFzcz1cImZvcm0taW5wdXRcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuICAgIDxsYWJlbCBbbmdDbGFzc109XCJjb25maWcubGFiZWxDbGFzc1wiICpuZ0lmPVwiY29uZmlnLmxhYmVsICYmIGNvbmZpZy5sYWJlbCE9JydcIj57eyBjb25maWcubGFiZWwgfX08L2xhYmVsPlxuICAgIDxkaXYgY2xhc3M9XCJkeW5hbWljLWZpZWxkIGZvcm0tYnV0dG9uXCI+XG4gICAgICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImNvbmZpZy5kaXNhYmxlZFwiIFtuZ0NsYXNzXT1cImNvbmZpZy5jbGFzc1wiIHR5cGU9XCJzdWJtaXRcIj5cbiAgICAgICAge3sgY29uZmlnLnRleHQgfX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1CdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBGaWVsZCwgQWZ0ZXJWaWV3SW5pdCwgRG9DaGVjayB7XG4gIGNvbmZpZzogRmllbGRDb25maWc7XG4gIGZvcm1Hcm91cDogRm9ybUdyb3VwO1xuICBkaWZmZXI6IGFueTtcbiAgYnRuOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzKSB7XG4gICAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xufVxuXG5cbkBIb3N0QmluZGluZygnY2xhc3MnKVxuZ2V0IGhvc3RDbGFzcygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZGl2Q2xhc3M7XG4gICAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLmJ0bik7XG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZm9ybScpLmNsYXNzTmFtZS5pbmNsdWRlcygnbmctaW52YWxpZCcpXG4gICAgICAgICAgJiYgdGhpcy5jb25maWcuaW5wdXRUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzdWJtaXQnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbmZpZy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIDEwICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBGaWVsZENvbmZpZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQtY29uZmlnLmludGVyZmFjZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICAgIGV4cG9ydEFzOiAnZHluYW1pY0Zvcm0nLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ2R5bmFtaWMtZm9ybScsXG4gICAgc3R5bGVzOiBbYC5fX25neC1mb3JtLWNvbnRhaW5lcntkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXB9YF0sXG4gICAgdGVtcGxhdGU6IGA8Zm9ybSBbZm9ybUdyb3VwXT1cImZvcm1cIiAjbmV3Rm9ybT1cIm5nRm9ybVwiIChuZ1N1Ym1pdCk9XCJoYW5kbGVTdWJtaXQoJGV2ZW50KVwiPlxuICAgIDxkaXYgY2xhc3M9XCJfX25neC1mb3JtLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGR5bmFtaWNGaWVsZCAqbmdGb3I9XCJsZXQgZmllbGQgb2YgY29uZmlnXCIgW2NvbmZpZ109XCJmaWVsZFwiIFtmb3JtR3JvdXBdPVwiZm9ybVwiPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZm9ybT5gXG59KVxuXG5leHBvcnQgY2xhc3MgRHluYW1pY0Zvcm1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIEBJbnB1dCgpIGNvbmZpZzogRmllbGRDb25maWdbXSA9IFtdO1xuICAgIGZpZWxkO1xuXG4gICAgQE91dHB1dCgpICBzdWJtaXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgZm9ybTogRm9ybUdyb3VwO1xuXG4gICAgZ2V0IGNvbnRyb2xzKCkgeyByZXR1cm4gdGhpcy5jb25maWcuZmlsdGVyKCh7dHlwZX0pID0+IHR5cGUgIT09ICdidXR0b24nKTsgfVxuICAgIGdldCBjaGFuZ2VzKCkgeyByZXR1cm4gdGhpcy5mb3JtLnZhbHVlQ2hhbmdlczsgfVxuICAgIGdldCB2YWxpZCgpIHsgcmV0dXJuIHRoaXMuZm9ybS52YWxpZDsgfVxuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuZm9ybS52YWx1ZTsgfVxuICAgIHJlc2V0KCl7IHRoaXMuZm9ybS5yZXNldCgpfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBmYjogRm9ybUJ1aWxkZXIpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5jcmVhdGVHcm91cCgpO1xuICAgIFxuICAgIH1cblxuXG4gICAgIC8qKlxuICAgICAgKiBDcmVhdGUgRm9ybUdyb3VwIGZvciB0aGUgRm9ybSB0byBiZSBnZW5lcmF0ZWRcbiAgICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVHcm91cCgpOiBGb3JtR3JvdXAge1xuICAgICAgICBjb25zdCBmb3JtR3JvdXAgPSB0aGlzLmZiLmdyb3VwKHt9KTtcbiAgICAgICAgdGhpcy5jb25maWcuZm9yRWFjaChjb250cm9sID0+IHtcbiAgICAgICAgICAgIGZvcm1Hcm91cC5hZGRDb250cm9sKGNvbnRyb2wubmFtZSwgdGhpcy5jcmVhdGVDb250cm9sKGNvbnRyb2wpKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGZvcm1Hcm91cDtcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIENyZWF0ZSBGb3JtIENvbnRyb2wgaW4gRm9ybUJ1aWxkZXJcbiAgICAgICogQHBhcmFtIGNvbmZpZyBcbiAgICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVDb250cm9sKGNvbmZpZzogRmllbGRDb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlZCwgdmFsaWRhdGlvbiwgdmFsdWUgfSA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmIuY29udHJvbCh7IGRpc2FibGVkLCB2YWx1ZSB9LCB2YWxpZGF0aW9uKTtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIEZvcm0gU3VibWl0XG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIGhhbmRsZVN1Ym1pdChldmVudDogRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuc3VibWl0LmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuXG5cbi8qKlxuICogRGlzYWJsZXMgYW4gZWxlbWVudCBpbiB0aGUgZm9ybVxuICogQHBhcmFtIG5hbWUgXG4gKiBAcGFyYW0gZGlzYWJsZSBcbiAqL1xuICAgIHNldERpc2FibGVkKG5hbWU6IHN0cmluZywgZGlzYWJsZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5mb3JtLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGRpc2FibGUgPyAnZGlzYWJsZScgOiAnZW5hYmxlJztcbiAgICAgICAgdGhpcy5mb3JtLmNvbnRyb2xzW25hbWVdW21ldGhvZF0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbmZpZy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRpc2FibGVkID0gZGlzYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGEgRm9ybSBjb250cm9sL2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gbmFtZSBcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICovXG4gICAgc2V0VmFsdWUobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5mb3JtLmNvbnRyb2xzW25hbWVdLnNldFZhbHVlKHZhbHVlLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLFxuICAgICAgICBJbnB1dCxcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBPbkluaXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyxcbiAgICAgICAgQ29tcG9uZW50UmVmLCBcbiAgICAgICAgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJ1xuXG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmllbGQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpZWxkQ29uZmlnfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpZWxkLWNvbmZpZy5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBGb3JtSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Zvcm0taW5wdXQvZm9ybS1pbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybUJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybVNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybUZpbGVVcGxvYWRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2ZpbGUtdXBsb2FkL2ZpbGUtdXBsb2FkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGb3JtRGF0ZXRpbWVDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2RhdGV0aW1lL2RhdGV0aW1lLmNvbXBvbmVudCc7XG5cbmNvbnN0IGNvbXBvbmVudHM6IHtbdHlwZTogc3RyaW5nXTogVHlwZTxGaWVsZD59ID0ge1xuICBidXR0b246IEZvcm1CdXR0b25Db21wb25lbnQsXG4gIGlucHV0OiBGb3JtSW5wdXRDb21wb25lbnQsXG4gIHNlbGVjdDogRm9ybVNlbGVjdENvbXBvbmVudCxcbiAgZmlsZTogRm9ybUZpbGVVcGxvYWRDb21wb25lbnQsXG4gIGRhdGU6IEZvcm1EYXRldGltZUNvbXBvbmVudFxufTtcblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2R5bmFtaWNGaWVsZF0nIH0pXG5leHBvcnQgY2xhc3MgRHluYW1pY0FkZEZpZWxkRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBGaWVsZCwgT25DaGFuZ2VzIHtcblxuICBASW5wdXQoKSBjb25maWc7XG4gIEBJbnB1dCgpIGZvcm1Hcm91cDogRm9ybUdyb3VwO1xuXG4gIGNvbXBvbmVudDogQ29tcG9uZW50UmVmPEZpZWxkPjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgaWYgKCFjb21wb25lbnRzW3RoaXMuY29uZmlnLnR5cGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3VwcG9ydGVkVHlwZXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKS5qb2luKCcsICcpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUcnlpbmcgdG8gdXNlIGFuIHVuc3VwcG9ydGVkIHR5cGUgKCR7dGhpcy5jb25maWcudHlwZX0pLlxuICAgICAgICAgICAgU3VwcG9ydGVkIHR5cGVzOiAke3N1cHBvcnRlZFR5cGVzfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1t0aGlzLmNvbmZpZy50eXBlXTtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3Rvcnk8RmllbGQ+KGNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gdGhpcy52Y3IuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS5jb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZm9ybUdyb3VwID0gdGhpcy5mb3JtR3JvdXA7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudCkgIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLmZvcm1Hcm91cCA9IHRoaXMuZm9ybUdyb3VwO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSZWFjdGl2ZUZvcm1zTW9kdWxlLCBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE5nRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJ25nMi1kYXRlcGlja2VyJztcblxuaW1wb3J0IHsgRHluYW1pY0Zvcm1Db21wb25lbnQgfSBmcm9tICcuL2NvbnRhaW5lcnMvZHluYW1pYy1mb3JtL2R5bmFtaWMtZm9ybS5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBGb3JtSW5wdXRDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZm9ybS1pbnB1dC9mb3JtLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQge0R5bmFtaWNBZGRGaWVsZERpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R5bmFtaWMtYWRkLWZpZWxkL2R5bmFtaWMtYWRkLWZpZWxkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGb3JtU2VsZWN0Q29tcG9uZW50LCBGb3JtRmlsZVVwbG9hZENvbXBvbmVudCwgRm9ybURhdGV0aW1lQ29tcG9uZW50LCBGb3JtQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi4vcHVibGljX2FwaSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBOZ0RhdGVwaWNrZXJNb2R1bGUsXG4gICAgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgIER5bmFtaWNBZGRGaWVsZERpcmVjdGl2ZSxcbiAgICAgIER5bmFtaWNGb3JtQ29tcG9uZW50LFxuICAgICAgRm9ybUlucHV0Q29tcG9uZW50LFxuICAgICAgRm9ybVNlbGVjdENvbXBvbmVudCxcbiAgICAgIEZvcm1GaWxlVXBsb2FkQ29tcG9uZW50LFxuICAgICAgRm9ybURhdGV0aW1lQ29tcG9uZW50LFxuICAgICAgRm9ybUJ1dHRvbkNvbXBvbmVudFxuICBdLFxuICBwcm92aWRlcnM6IFtcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIE5nRGF0ZXBpY2tlck1vZHVsZSxcbiAgICBEeW5hbWljRm9ybUNvbXBvbmVudFxuICBdLCBzY2hlbWFzOiBbXG4gICAgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQVxuXSxcbiAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgRm9ybUlucHV0Q29tcG9uZW50LFxuICAgIEZvcm1TZWxlY3RDb21wb25lbnQsXG4gICAgRm9ybUZpbGVVcGxvYWRDb21wb25lbnQsXG4gICAgRm9ybURhdGV0aW1lQ29tcG9uZW50LFxuICAgIEZvcm1CdXR0b25Db21wb25lbnRcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEeW5hbWljRm9ybU1vZHVsZSB7fVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0lBdUNJLGlCQUFpQjs7OztJQUVqQixJQUNJLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO0tBQy9COzs7WUF0Q1IsU0FBUyxTQUFDOztnQkFFUCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIsTUFBTSxFQUFFLENBQUMsZ01BQWdNLEVBQUUsZ01BQWdNLENBQUM7Z0JBQzVZLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QlA7YUFDTjs7Ozs7d0JBT0ksV0FBVyxTQUFDLE9BQU87Ozs7Ozs7QUN6Q3hCOzs7O0lBa0NFLElBQ00sU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7S0FDL0I7Ozs7OztJQU1QLFdBQVcsQ0FBQyxHQUFXOztRQUNyQixNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7O1FBQ3JCLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQzs7UUFDbEIsTUFBTSxhQUFhLEdBQUcs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